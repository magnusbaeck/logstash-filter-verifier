// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package session_test

import (
	"sync"

	"github.com/magnusbaeck/logstash-filter-verifier/v2/internal/daemon/pipeline"
	"github.com/magnusbaeck/logstash-filter-verifier/v2/internal/daemon/session"
)

// Ensure, that LogstashControllerMock does implement session.LogstashController.
// If this is not the case, regenerate this file with moq.
var _ session.LogstashController = &LogstashControllerMock{}

// LogstashControllerMock is a mock implementation of session.LogstashController.
//
//	func TestSomethingThatUsesLogstashController(t *testing.T) {
//
//		// make and configure a mocked session.LogstashController
//		mockedLogstashController := &LogstashControllerMock{
//			ExecuteTestFunc: func(pipelines pipeline.Pipelines, expectedEvents int) error {
//				panic("mock out the ExecuteTest method")
//			},
//			GetResultsFunc: func() ([]string, error) {
//				panic("mock out the GetResults method")
//			},
//			IsHealthyFunc: func() bool {
//				panic("mock out the IsHealthy method")
//			},
//			KillFunc: func()  {
//				panic("mock out the Kill method")
//			},
//			SetupTestFunc: func(pipelines pipeline.Pipelines) error {
//				panic("mock out the SetupTest method")
//			},
//			TeardownFunc: func() error {
//				panic("mock out the Teardown method")
//			},
//		}
//
//		// use mockedLogstashController in code that requires session.LogstashController
//		// and then make assertions.
//
//	}
type LogstashControllerMock struct {
	// ExecuteTestFunc mocks the ExecuteTest method.
	ExecuteTestFunc func(pipelines pipeline.Pipelines, expectedEvents int) error

	// GetResultsFunc mocks the GetResults method.
	GetResultsFunc func() ([]string, error)

	// IsHealthyFunc mocks the IsHealthy method.
	IsHealthyFunc func() bool

	// KillFunc mocks the Kill method.
	KillFunc func()

	// SetupTestFunc mocks the SetupTest method.
	SetupTestFunc func(pipelines pipeline.Pipelines) error

	// TeardownFunc mocks the Teardown method.
	TeardownFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// ExecuteTest holds details about calls to the ExecuteTest method.
		ExecuteTest []struct {
			// Pipelines is the pipelines argument value.
			Pipelines pipeline.Pipelines
			// ExpectedEvents is the expectedEvents argument value.
			ExpectedEvents int
		}
		// GetResults holds details about calls to the GetResults method.
		GetResults []struct {
		}
		// IsHealthy holds details about calls to the IsHealthy method.
		IsHealthy []struct {
		}
		// Kill holds details about calls to the Kill method.
		Kill []struct {
		}
		// SetupTest holds details about calls to the SetupTest method.
		SetupTest []struct {
			// Pipelines is the pipelines argument value.
			Pipelines pipeline.Pipelines
		}
		// Teardown holds details about calls to the Teardown method.
		Teardown []struct {
		}
	}
	lockExecuteTest sync.RWMutex
	lockGetResults  sync.RWMutex
	lockIsHealthy   sync.RWMutex
	lockKill        sync.RWMutex
	lockSetupTest   sync.RWMutex
	lockTeardown    sync.RWMutex
}

// ExecuteTest calls ExecuteTestFunc.
func (mock *LogstashControllerMock) ExecuteTest(pipelines pipeline.Pipelines, expectedEvents int) error {
	if mock.ExecuteTestFunc == nil {
		panic("LogstashControllerMock.ExecuteTestFunc: method is nil but LogstashController.ExecuteTest was just called")
	}
	callInfo := struct {
		Pipelines      pipeline.Pipelines
		ExpectedEvents int
	}{
		Pipelines:      pipelines,
		ExpectedEvents: expectedEvents,
	}
	mock.lockExecuteTest.Lock()
	mock.calls.ExecuteTest = append(mock.calls.ExecuteTest, callInfo)
	mock.lockExecuteTest.Unlock()
	return mock.ExecuteTestFunc(pipelines, expectedEvents)
}

// ExecuteTestCalls gets all the calls that were made to ExecuteTest.
// Check the length with:
//
//	len(mockedLogstashController.ExecuteTestCalls())
func (mock *LogstashControllerMock) ExecuteTestCalls() []struct {
	Pipelines      pipeline.Pipelines
	ExpectedEvents int
} {
	var calls []struct {
		Pipelines      pipeline.Pipelines
		ExpectedEvents int
	}
	mock.lockExecuteTest.RLock()
	calls = mock.calls.ExecuteTest
	mock.lockExecuteTest.RUnlock()
	return calls
}

// GetResults calls GetResultsFunc.
func (mock *LogstashControllerMock) GetResults() ([]string, error) {
	if mock.GetResultsFunc == nil {
		panic("LogstashControllerMock.GetResultsFunc: method is nil but LogstashController.GetResults was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetResults.Lock()
	mock.calls.GetResults = append(mock.calls.GetResults, callInfo)
	mock.lockGetResults.Unlock()
	return mock.GetResultsFunc()
}

// GetResultsCalls gets all the calls that were made to GetResults.
// Check the length with:
//
//	len(mockedLogstashController.GetResultsCalls())
func (mock *LogstashControllerMock) GetResultsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetResults.RLock()
	calls = mock.calls.GetResults
	mock.lockGetResults.RUnlock()
	return calls
}

// IsHealthy calls IsHealthyFunc.
func (mock *LogstashControllerMock) IsHealthy() bool {
	if mock.IsHealthyFunc == nil {
		panic("LogstashControllerMock.IsHealthyFunc: method is nil but LogstashController.IsHealthy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsHealthy.Lock()
	mock.calls.IsHealthy = append(mock.calls.IsHealthy, callInfo)
	mock.lockIsHealthy.Unlock()
	return mock.IsHealthyFunc()
}

// IsHealthyCalls gets all the calls that were made to IsHealthy.
// Check the length with:
//
//	len(mockedLogstashController.IsHealthyCalls())
func (mock *LogstashControllerMock) IsHealthyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsHealthy.RLock()
	calls = mock.calls.IsHealthy
	mock.lockIsHealthy.RUnlock()
	return calls
}

// Kill calls KillFunc.
func (mock *LogstashControllerMock) Kill() {
	if mock.KillFunc == nil {
		panic("LogstashControllerMock.KillFunc: method is nil but LogstashController.Kill was just called")
	}
	callInfo := struct {
	}{}
	mock.lockKill.Lock()
	mock.calls.Kill = append(mock.calls.Kill, callInfo)
	mock.lockKill.Unlock()
	mock.KillFunc()
}

// KillCalls gets all the calls that were made to Kill.
// Check the length with:
//
//	len(mockedLogstashController.KillCalls())
func (mock *LogstashControllerMock) KillCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockKill.RLock()
	calls = mock.calls.Kill
	mock.lockKill.RUnlock()
	return calls
}

// SetupTest calls SetupTestFunc.
func (mock *LogstashControllerMock) SetupTest(pipelines pipeline.Pipelines) error {
	if mock.SetupTestFunc == nil {
		panic("LogstashControllerMock.SetupTestFunc: method is nil but LogstashController.SetupTest was just called")
	}
	callInfo := struct {
		Pipelines pipeline.Pipelines
	}{
		Pipelines: pipelines,
	}
	mock.lockSetupTest.Lock()
	mock.calls.SetupTest = append(mock.calls.SetupTest, callInfo)
	mock.lockSetupTest.Unlock()
	return mock.SetupTestFunc(pipelines)
}

// SetupTestCalls gets all the calls that were made to SetupTest.
// Check the length with:
//
//	len(mockedLogstashController.SetupTestCalls())
func (mock *LogstashControllerMock) SetupTestCalls() []struct {
	Pipelines pipeline.Pipelines
} {
	var calls []struct {
		Pipelines pipeline.Pipelines
	}
	mock.lockSetupTest.RLock()
	calls = mock.calls.SetupTest
	mock.lockSetupTest.RUnlock()
	return calls
}

// Teardown calls TeardownFunc.
func (mock *LogstashControllerMock) Teardown() error {
	if mock.TeardownFunc == nil {
		panic("LogstashControllerMock.TeardownFunc: method is nil but LogstashController.Teardown was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTeardown.Lock()
	mock.calls.Teardown = append(mock.calls.Teardown, callInfo)
	mock.lockTeardown.Unlock()
	return mock.TeardownFunc()
}

// TeardownCalls gets all the calls that were made to Teardown.
// Check the length with:
//
//	len(mockedLogstashController.TeardownCalls())
func (mock *LogstashControllerMock) TeardownCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTeardown.RLock()
	calls = mock.calls.Teardown
	mock.lockTeardown.RUnlock()
	return calls
}
